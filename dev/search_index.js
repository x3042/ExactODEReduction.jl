var documenterSearchIndex = {"docs":
[{"location":"guide/#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"The algorithms in this package take as input a system of ODEs with polynomial right-hand side and return the new variable substitution(s) and the corresponding system(s).","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Consider the folliwing system of differential equations","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"begincases \ndotx_1 = x_1^2 + 2x_1x_2 \ndotx_2 =  x_2^2 + x_3 + x_4 \ndotx_3 = x_2 + x_4 \ndotx_4 = x_1 + x_3 \nendcases","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"To create a system as above, one can use the ODEsystem macro. This is the easiest way to do so.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using ExactODEReduction\n\nodes = @ODEsystem(\n    x1'(t) = x1^2 + a*x1*x2,\n    x2'(t) = x2^2 + x3,\n    x3'(t) = x2 - x3\n)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"After using the macro, we use find_reductions function. This function accepts the ODE model and outputs a list of possible linear reductions.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"find_reductions(odes)","category":"page"},{"location":"reductions/#Functions-for-finding-reductions","page":"Functions for finding reductions","title":"Functions for finding reductions","text":"","category":"section"},{"location":"reductions/","page":"Functions for finding reductions","title":"Functions for finding reductions","text":"find_reductions","category":"page"},{"location":"reductions/#ExactODEReduction.find_reductions","page":"Functions for finding reductions","title":"ExactODEReduction.find_reductions","text":"find_reductions(system::ODE; overQ=true, makepositive=false, loglevel=Logging.Info)\n\nFinds reductions of the system corresponding to a Jordan-Hoelder filtration. This means that the reduction form a chain, and there are no extra intermediate reduction in this chain. In particular, if there exists at least one reduction, it will be found.\n\nArguments:\n\nsystem is an ODE system given as ODE object,\noverQ tells the algorithm to search for reductions over rational numbers,\nmakepositive tells the algorithm to search for reductions with positive coefficients. \n\nTo enable this argument, you should have Polymake.jl imported. \n\nExample:\n\njulia> using ExactODEReduction\njulia> odes = @ODEsystem(\n    x'(t) = x + y,\n    y'(t) = x - y - z,\n    z'(t) = 2x - z\n)\njulia> find_reductions(odes)\n2-element Vector{Dict{Symbol, Any}}:\n Dict(:new_system => y1'(t) = 0\n, :new_vars => Nemo.fmpq_mpoly[y - z + x])\n Dict(:new_system => y2'(t) = -y1(t) - y2(t)\ny1'(t) = -y1(t) - y2(t)\n, :new_vars => Nemo.fmpq_mpoly[y, z - x])\n\n\n\n\n\n","category":"function"},{"location":"reductions/","page":"Functions for finding reductions","title":"Functions for finding reductions","text":"find_smallest_constrained_reduction","category":"page"},{"location":"reductions/#ExactODEReduction.find_smallest_constrained_reduction","page":"Functions for finding reductions","title":"ExactODEReduction.find_smallest_constrained_reduction","text":"find_smallest_constrained_reduction(system::ODE, observables; overQ=true, makepositive=false, loglevel=Logging.Info)\n\nFinds the best linear reduction of the system. If there exists a reduction, it will be found. Arguments:\n\nsystem is an ODE system given as ODE object,\nobservables is a list of linear functions of initial variables  desired to be preserved by reduction,\noverQ tells the algorithm to search for reductions over rational numbers,\nmakepositive tells the algorithm to search for reductions with positive coefficients;\n\nTo enable this argument, you should have Polymake.jl imported. \n\nExample:\n\njulia> using ExactODEReduction\njulia> odes = @ODEsystem(\n    x'(t) = x + y,\n    y'(t) = x - y - z,\n    z'(t) = 2x - z\n)\njulia> find_smallest_constrained_reduction(odes, [2x + z])\nDict{Symbol, Any} with 2 entries:\n  :new_system => y2'(t) = 2*y1(t) - y2(t)…\n  :new_vars   => Nemo.fmpq_mpoly[y + 3*x, z + 2*x]\n\n\n\n\n\n","category":"function"},{"location":"reductions/","page":"Functions for finding reductions","title":"Functions for finding reductions","text":"find_some_reduction","category":"page"},{"location":"reductions/#ExactODEReduction.find_some_reduction","page":"Functions for finding reductions","title":"ExactODEReduction.find_some_reduction","text":"find_some_reduction(system::ODE, observables; overQ=true, makepositive=false, loglevel=Logging.Info)\n\nFinds a nontrivial linear reduction of the system. If there exists a reduction, it will be found.\n\nArguments:\n\nsystem is an ODE system given as ODE object,\noverQ tells the algorithm to search for reductions over rational numbers,\nmakepositive tells the algorithm to search for reductions with positive coefficients;\n\nTo enable this argument, you should have Polymake.jl imported. \n\nExample:\n\njulia> using ExactODEReduction\njulia> odes = @ODEsystem(\n    x'(t) = x + y,\n    y'(t) = x - y - z,\n    z'(t) = 2x - z\n)\njulia> find_some_reduction(odes)\nDict{Symbol, Any} with 2 entries:\n  :new_system => y2'(t) = -y1(t) - y2(t)…\n  :new_vars   => Nemo.fmpq_mpoly[y, z - x]\n\n\n\n\n\n","category":"function"},{"location":"#ExactODEReduction.jl-Documentation","page":"ExactODEReduction","title":"ExactODEReduction.jl Documentation","text":"","category":"section"},{"location":"","page":"ExactODEReduction","title":"ExactODEReduction","text":"The ExactODEReduction.jl package provides an algorithm for computing exact linear reductions of ODE systems. It allows computing a longest possible chain of reductions corresponding to a Jordan-Hoelder filtration.","category":"page"},{"location":"","page":"ExactODEReduction","title":"ExactODEReduction","text":"This documentation contains information about the functionality of the package as well as examples of use cases. See the Guide section for a quick introduction.","category":"page"},{"location":"#Installation","page":"ExactODEReduction","title":"Installation","text":"","category":"section"},{"location":"","page":"ExactODEReduction","title":"ExactODEReduction","text":"To install ExactODEReduction.jl, run the following command in Julia:","category":"page"},{"location":"","page":"ExactODEReduction","title":"ExactODEReduction","text":"import Pkg\nPkg.add(url=\"https://github.com/x3042/Exact-reduction-of-ODE-systems\")","category":"page"},{"location":"","page":"ExactODEReduction","title":"ExactODEReduction","text":"The package dependency on polymake is optional; it is loaded lazily if necessary, and most of the package functionality works without it.","category":"page"},{"location":"#Citation","page":"ExactODEReduction","title":"Citation","text":"","category":"section"},{"location":"","page":"ExactODEReduction","title":"ExactODEReduction","text":"/\n","category":"page"},{"location":"#Features","page":"ExactODEReduction","title":"Features","text":"","category":"section"},{"location":"","page":"ExactODEReduction","title":"ExactODEReduction","text":"Given an ODE system with polynomial right-hand side, ExactODEReduction.jl computes a smaller, reduced system, with macro-parameters expressed as linear combinations of the original ones. ","category":"page"},{"location":"","page":"ExactODEReduction","title":"ExactODEReduction","text":"The main feature of the package is the algorithm for computing a longest chain of such reductions.","category":"page"},{"location":"#Feature-list","page":"ExactODEReduction","title":"Feature list","text":"","category":"section"},{"location":"","page":"ExactODEReduction","title":"ExactODEReduction","text":"Computed reductions are always exact transformations,\nAllows coefficients from rational numbers, as well as its extension,\nNew macro-variables can be conic combinations of original ones.","category":"page"},{"location":"io/#Functions-for-creating-ODEs","page":"Functions for creating ODEs","title":"Functions for creating ODEs","text":"","category":"section"},{"location":"io/","page":"Functions for creating ODEs","title":"Functions for creating ODEs","text":"@ODEsystem","category":"page"},{"location":"io/#ExactODEReduction.@ODEsystem","page":"Functions for creating ODEs","title":"ExactODEReduction.@ODEsystem","text":"@ODEsystem\n\nMacro for creating an ODE from a list of equations.\nAlso injects all variables into the global scope.\nThis macro accepts a sybolically written ODE system and generates an `ODE` structure instance:\n```julia\node = @ODEsystem(\n    x1'(t) = -k1 * x1(t),\n    x2'(t) = -k2 * x2(t)\n)\n[ Info: Summary of the model:\n[ Info: State variables: x2, x1\n[ Info: Parameters: k1, k2\nk2'(t) = 0\nx2'(t) = -x2(t)*k2(t)\nx1'(t) = -k1(t)*x1(t)\nk1'(t) = 0\n```\n\n\n\n\n\n","category":"macro"},{"location":"io/","page":"Functions for creating ODEs","title":"Functions for creating ODEs","text":"ODE{P}","category":"page"},{"location":"io/#ExactODEReduction.ODE","page":"Functions for creating ODEs","title":"ExactODEReduction.ODE","text":"ODE{P}\n\nThe main structure that represents input ODE system.\nStores information about states (`x_vars`), and the equations.\nThis structure is constructed via `@ODEmodel` macro.\n\n\n\n\n\n","category":"type"},{"location":"io/","page":"Functions for creating ODEs","title":"Functions for creating ODEs","text":"equations","category":"page"},{"location":"io/#ExactODEReduction.equations","page":"Functions for creating ODEs","title":"ExactODEReduction.equations","text":"equations(ode::ODE)\n\nReturns the equations that define the given ODE system.\n\n\n\n\n\n","category":"function"}]
}
