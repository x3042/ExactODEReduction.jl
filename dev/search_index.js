var documenterSearchIndex = {"docs":
[{"location":"guide/#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"The algorithms in this package take as input a system of ODEs with polynomial right-hand side and return the new variable expressions and the corresponding system(s).","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Consider the folliwing system of differential equations","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"begincases \ndotx_1 = x_1^2 + 2x_1x_2 \ndotx_2 =  x_2^2 + x_3 + x_4 \ndotx_3 = x_2 + x_4 \ndotx_4 = x_1 + x_3 \nendcases","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"To create a system as above in ExactODEReduction, one can use the ODEsystem macro. This is the easiest way to do so.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using ExactODEReduction\n\nodes = @ODEsystem(\n    x1'(t) = x_1^2 + 2x_1x_2,\n    x2'(t) = x_2^2 + x_3 + x_4,\n    x3'(t) = x_2 + x_4,\n    x4'(t) = x_1 + x_3\n)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"After using the macro, we can use find_reductions function. This function accepts the ODE model and outputs possible linear reductions.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"reds = find_reductions(odes)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"The reds object can be treated as an array. For example, to access the second reduction from the list, type","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"red = reds[2]","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Further, we can use new_system and new_vars functions to explore this reduction.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"new_ode = new_system(red)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"new_vars = new_vars(red)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Note that new_ode from above is again an ODE object. In particular, this means that all functions from Section Functions for manipulating ODEs will also work for it.","category":"page"},{"location":"reductions/#Functions-for-finding-reductions","page":"Functions for finding reductions","title":"Functions for finding reductions","text":"","category":"section"},{"location":"reductions/","page":"Functions for finding reductions","title":"Functions for finding reductions","text":"find_reductions","category":"page"},{"location":"reductions/#ExactODEReduction.find_reductions","page":"Functions for finding reductions","title":"ExactODEReduction.find_reductions","text":"find_reductions(system::ODE; overQ=true, makepositive=false, loglevel=Logging.Info)\n\nFinds reductions of the system corresponding to a Jordan-Hoelder filtration. This means that the reduction form a chain, and there are no extra intermediate reduction in this chain. In particular, if there exists at least one reduction, it will be found.\n\nArguments:\n\nsystem is an ODE system given as ODE object,\noverQ tells the algorithm to search for reductions over rational numbers,\nmakepositive tells the algorithm to search for reductions with positive coefficients. \n\nTo enable this argument, you should have Polymake.jl imported. \n\nExample:\n\njulia> using ExactODEReduction\njulia> odes = @ODEsystem(\n    x'(t) = x + y,\n    y'(t) = x - y - z,\n    z'(t) = 2x - z\n)\njulia> find_reductions(odes)\n2-element Vector{Dict{Symbol, Any}}:\n Dict(:new_system => y1'(t) = 0\n, :new_vars => Nemo.fmpq_mpoly[y - z + x])\n Dict(:new_system => y2'(t) = -y1(t) - y2(t)\ny1'(t) = -y1(t) - y2(t)\n, :new_vars => Nemo.fmpq_mpoly[y, z - x])\n\n\n\n\n\n","category":"function"},{"location":"reductions/","page":"Functions for finding reductions","title":"Functions for finding reductions","text":"find_smallest_constrained_reduction","category":"page"},{"location":"reductions/#ExactODEReduction.find_smallest_constrained_reduction","page":"Functions for finding reductions","title":"ExactODEReduction.find_smallest_constrained_reduction","text":"find_smallest_constrained_reduction(system::ODE, observables; overQ=true, makepositive=false, loglevel=Logging.Info)\n\nFinds the best linear reduction of the system. If there exists a reduction, it will be found. Arguments:\n\nsystem is an ODE system given as ODE object,\nobservables is a list of linear functions of initial variables  desired to be preserved by reduction,\noverQ tells the algorithm to search for reductions over rational numbers,\nmakepositive tells the algorithm to search for reductions with positive coefficients;\n\nTo enable this argument, you should have Polymake.jl imported. \n\nExample:\n\njulia> using ExactODEReduction\njulia> odes = @ODEsystem(\n    x'(t) = x + y,\n    y'(t) = x - y - z,\n    z'(t) = 2x - z\n)\njulia> find_smallest_constrained_reduction(odes, [2x + z])\nDict{Symbol, Any} with 2 entries:\n  :new_system => y2'(t) = 2*y1(t) - y2(t)…\n  :new_vars   => Nemo.fmpq_mpoly[y + 3*x, z + 2*x]\n\n\n\n\n\n","category":"function"},{"location":"reductions/","page":"Functions for finding reductions","title":"Functions for finding reductions","text":"find_some_reduction","category":"page"},{"location":"reductions/#ExactODEReduction.find_some_reduction","page":"Functions for finding reductions","title":"ExactODEReduction.find_some_reduction","text":"find_some_reduction(system::ODE, observables; overQ=true, makepositive=false, loglevel=Logging.Info)\n\nFinds a nontrivial linear reduction of the system. If there exists a reduction, it will be found.\n\nArguments:\n\nsystem is an ODE system given as ODE object,\noverQ tells the algorithm to search for reductions over rational numbers,\nmakepositive tells the algorithm to search for reductions with positive coefficients;\n\nTo enable this argument, you should have Polymake.jl imported. \n\nExample:\n\njulia> using ExactODEReduction\njulia> odes = @ODEsystem(\n    x'(t) = x + y,\n    y'(t) = x - y - z,\n    z'(t) = 2x - z\n)\njulia> find_some_reduction(odes)\nDict{Symbol, Any} with 2 entries:\n  :new_system => y2'(t) = -y1(t) - y2(t)…\n  :new_vars   => Nemo.fmpq_mpoly[y, z - x]\n\n\n\n\n\n","category":"function"},{"location":"reductions/#Functions-for-exploring-found-reductions","page":"Functions for finding reductions","title":"Functions for exploring found reductions","text":"","category":"section"},{"location":"reductions/","page":"Functions for finding reductions","title":"Functions for finding reductions","text":"new_system","category":"page"},{"location":"reductions/#ExactODEReduction.new_system","page":"Functions for finding reductions","title":"ExactODEReduction.new_system","text":"new_system(r::Reduction)\n\nReturns the `ODE` object that defines the reduced system.\n\n\n\n\n\n","category":"function"},{"location":"reductions/","page":"Functions for finding reductions","title":"Functions for finding reductions","text":"new_vars","category":"page"},{"location":"reductions/#ExactODEReduction.new_vars","page":"Functions for finding reductions","title":"ExactODEReduction.new_vars","text":"new_system(r::Reduction)\n\nReturns the dictionary of new macro-variables expressed\nas linear combinations of the original variables.\n\n\n\n\n\n","category":"function"},{"location":"load/#Functions-for-loading-ODEs-from-a-file","page":"Functions for loading ODEs from a file","title":"Functions for loading ODEs from a file","text":"","category":"section"},{"location":"load/","page":"Functions for loading ODEs from a file","title":"Functions for loading ODEs from a file","text":"load_ODE_fromfile","category":"page"},{"location":"load/#ExactODEReduction.load_ODE_fromfile","page":"Functions for loading ODEs from a file","title":"ExactODEReduction.load_ODE_fromfile","text":"load_ODE_fromfile(filepath, load_ic=false)\n\nReturns the `ODE` object constructed from equations\nin the `*.ode` file at `filepath`.\n\nFor the format `*.ode` see the `examples` folder.\n\nIf `load_ic` is set, also returns the list of initial conditions \n(if specified in the file).\n\n\n\n\n\n","category":"function"},{"location":"#ExactODEReduction.jl-Documentation","page":"ExactODEReduction","title":"ExactODEReduction.jl Documentation","text":"","category":"section"},{"location":"","page":"ExactODEReduction","title":"ExactODEReduction","text":"The ExactODEReduction.jl package provides an algorithm for computing exact linear reductions of ODE systems. It finds a longest possible chain of reductions corresponding to Jordan-Hoelder filtration.","category":"page"},{"location":"","page":"ExactODEReduction","title":"ExactODEReduction","text":"This documentation contains information about the functionality of the package as well as examples of use cases. See the Guide section for a quick introduction.","category":"page"},{"location":"#Installation","page":"ExactODEReduction","title":"Installation","text":"","category":"section"},{"location":"","page":"ExactODEReduction","title":"ExactODEReduction","text":"To install ExactODEReduction.jl, run the following command in Julia:","category":"page"},{"location":"","page":"ExactODEReduction","title":"ExactODEReduction","text":"import Pkg\nPkg.add(url=\"https://github.com/x3042/Exact-reduction-of-ODE-systems\")","category":"page"},{"location":"","page":"ExactODEReduction","title":"ExactODEReduction","text":"The package dependency on polymake is optional; it is loaded lazily only if necessary, and most of the package functionality works without it.","category":"page"},{"location":"#Citation","page":"ExactODEReduction","title":"Citation","text":"","category":"section"},{"location":"","page":"ExactODEReduction","title":"ExactODEReduction","text":"/\n","category":"page"},{"location":"#Features","page":"ExactODEReduction","title":"Features","text":"","category":"section"},{"location":"","page":"ExactODEReduction","title":"ExactODEReduction","text":"Given an ODE system with polynomial right-hand side, ExactODEReduction.jl computes a smaller, reduced system, with macro-parameters expressed as linear combinations of the original ones. ","category":"page"},{"location":"","page":"ExactODEReduction","title":"ExactODEReduction","text":"The main feature of the package is the algorithm for computing a longest chain of such reductions.","category":"page"},{"location":"#Feature-list","page":"ExactODEReduction","title":"Feature list","text":"","category":"section"},{"location":"","page":"ExactODEReduction","title":"ExactODEReduction","text":"Computed reductions are always exact transformations,\nAllows coefficients from rational numbers, as well as its extension,\nEnables expressing new macro-variables as conic combinations of the original ones.","category":"page"},{"location":"io/#Functions-for-manipulating-ODEs","page":"Functions for manipulating ODEs","title":"Functions for manipulating ODEs","text":"","category":"section"},{"location":"io/","page":"Functions for manipulating ODEs","title":"Functions for manipulating ODEs","text":"@ODEsystem","category":"page"},{"location":"io/#ExactODEReduction.@ODEsystem","page":"Functions for manipulating ODEs","title":"ExactODEReduction.@ODEsystem","text":"@ODEsystem\n\nMacro for creating an ODE from a list of equations. Also injects all variables into the global scope. This macro accepts a sybolically written ODE system and generates an ODE structure instance.\n\nExample:\n\node = @ODEsystem(\n    x1'(t) = -k1 * x1(t),\n    x2'(t) = -k2 * x2(t)\n)\n[ Info: Summary of the model:\n[ Info: State variables: x2, x1\n[ Info: Parameters: k1, k2\nk2'(t) = 0\nx2'(t) = -x2(t)*k2(t)\nx1'(t) = -k1(t)*x1(t)\nk1'(t) = 0\n\n\n\n\n\n","category":"macro"},{"location":"io/","page":"Functions for manipulating ODEs","title":"Functions for manipulating ODEs","text":"ODE{P}","category":"page"},{"location":"io/#ExactODEReduction.ODE","page":"Functions for manipulating ODEs","title":"ExactODEReduction.ODE","text":"struct ODE{P}\n\nThe main structure that represents input ODE system.\nStores information about states and the equations.\nThis structure is constructed via the `@ODEmodel` macro.\n\n\n\n\n\n","category":"type"},{"location":"io/#Accessing-ODE-data","page":"Functions for manipulating ODEs","title":"Accessing ODE data","text":"","category":"section"},{"location":"io/","page":"Functions for manipulating ODEs","title":"Functions for manipulating ODEs","text":"","category":"page"},{"location":"io/","page":"Functions for manipulating ODEs","title":"Functions for manipulating ODEs","text":"@docs equations","category":"page"},{"location":"io/","page":"Functions for manipulating ODEs","title":"Functions for manipulating ODEs","text":"","category":"page"},{"location":"io/","page":"Functions for manipulating ODEs","title":"Functions for manipulating ODEs","text":"@docs vars","category":"page"},{"location":"io/","page":"Functions for manipulating ODEs","title":"Functions for manipulating ODEs","text":"\n### Converting ODE to `MTK.jl` and back\n","category":"page"},{"location":"io/","page":"Functions for manipulating ODEs","title":"Functions for manipulating ODEs","text":"@docs ODEtoMTK","category":"page"},{"location":"io/","page":"Functions for manipulating ODEs","title":"Functions for manipulating ODEs","text":"","category":"page"},{"location":"io/","page":"Functions for manipulating ODEs","title":"Functions for manipulating ODEs","text":"@docs MTKtoODE ```","category":"page"}]
}
